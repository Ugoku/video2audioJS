<!DOCTYPE html5>
<html>
<head>
<title>test</title>
<script>window.onerror=function(msg,url,ln,col,err){alert('Error\n\n'+msg+'\nLine '+ln+'\nColumn '+col+'\nStack Trace\n'+err);}</script>
</head>
<body>
<input type="url" placeholder="Enter CORS-enabled video URL here."/>
<button onclick="go();">Go!</button>

<script>
function go(){
function getBuffer(resolve) {
    var reader = new FileReader();
    reader.onload = function () {
        var arrayBuffer = reader.result;
        resolve(arrayBuffer);
    }
    reader.readAsArrayBuffer(new Blob([document.querySelector("input").files[0]]));
}
var audioContext = new(window.AudioContext || window.webkitAudioContext)();
//fileData = new Blob([input.files[0]]);
var videoFileAsBuffer = new Promise(getBuffer);
videoFileAsBuffer.then(function (data) {
   alert();
    audioContext.decodeAudioData(data).then(function (decodedAudioData) {
        var offlineAudioContext = new (OfflineAudioContext||webkitOfflineAudioContext)(2, 44100 * 100, 44100);
        var soundSource = offlineAudioContext.createBufferSource();
        mySoundBuffer = decodedAudioData;
        soundSource = audioContext.createBufferSource();
        soundSource.buffer = mySoundBuffer;
        // soundSource.connect(audioContext.destination);
        // soundSource.start();
        soundSource.connect(offlineAudioContext.destination);
        soundSource.start();
        offlineAudioContext.startRendering().then(function (renderedBuffer) {
        alert(renderedBuffer); // outputs audiobuffer
        var song = audioContext.createBufferSource();
        song.buffer = renderedBuffer;
        song.connect(audioContext.destination);
        song.start();
        }).catch(function (err) {alert('Rendering failed: ' + err);});
    });
});

/*
var actx = new(AudioContext || webkitAudioContext)(),
    url = document.querySelector("input[type=url]").value=""?"rabbit320.mp4":document.querySelector("input[type=url]").value;
// STEP 1: Load audio file using AJAX ----------------------------------
loadXHR(url, decode);
function loadXHR(url, callback) {
  try {
    var xhr = new XMLHttpRequest();
    xhr.open("GET", url);
    xhr.responseType = "arraybuffer";
    xhr.onerror = function() {console.log("Network error.")};
    xhr.onload = function() {
      if (xhr.status === 200) callback(xhr.response);
      else console.log("Loading error:" + xhr.statusText);
    };
    xhr.send();
  } catch (err) {console.log(err.message)}
}
// STEP 2: Decode the audio file ---------------------------------------
function decode(buffer) {
  actx.decodeAudioData(buffer, split).catch(function (err) {alert('Rendering failed: ' + err);});
}
// STEP 3: Split the buffer --------------------------------------------
function split(abuffer) {
  // calc number of segments and segment length
  var channels = abuffer.numberOfChannels,
      duration = abuffer.duration,
      rate = abuffer.sampleRate,
      segmentLen = 10,
      count = Math.floor(duration / segmentLen),
      offset = 0,
      block = 10 * rate;
  while(count--) {
    var url = URL.createObjectURL(bufferToWave(abuffer, offset, block));
    var audio = new Audio(url);
    audio.controls = true;
    audio.volume = 0.5;
    document.body.appendChild(audio);
    offset += block;
  }  
}
// Convert a audio-buffer segment to a Blob using WAVE representation
function bufferToWave(abuffer, offset, len) {
  var numOfChan = abuffer.numberOfChannels,
      length = len * numOfChan * 2 + 44,
      buffer = new ArrayBuffer(length),
      view = new DataView(buffer),
      channels = [], i, sample,
      pos = 0;
  // write WAVE header
  setUint32(0x46464952);                         // "RIFF"
  setUint32(length - 8);                         // file length - 8
  setUint32(0x45564157);                         // "WAVE"

  setUint32(0x20746d66);                         // "fmt " chunk
  setUint32(16);                                 // length = 16
  setUint16(1);                                  // PCM (uncompressed)
  setUint16(numOfChan);
  setUint32(abuffer.sampleRate);
  setUint32(abuffer.sampleRate * 2 * numOfChan); // avg. bytes/sec
  setUint16(numOfChan * 2);                      // block-align
  setUint16(16);                                 // 16-bit (hardcoded in this demo)

  setUint32(0x61746164);                         // "data" - chunk
  setUint32(length - pos - 4);                   // chunk length
  // write interleaved data
  for(i = 0; i < abuffer.numberOfChannels; i++)
    channels.push(abuffer.getChannelData(i));
  while(pos < length) {
    for(i = 0; i < numOfChan; i++) {             // interleave channels
      sample = Math.max(-1, Math.min(1, channels[i][offset])); // clamp
      sample = (0.5 + sample < 0 ? sample * 32768 : sample * 32767)|0; // scale to 16-bit signed int
      view.setInt16(pos, sample, true);          // update data chunk
      pos += 2;
    }
    offset++                                     // next source sample
  }
  // create Blob
  return new Blob([buffer], {type: "audio/wav"});
  function setUint16(data) {
    view.setUint16(pos, data, true);
    pos += 2;
  }
  function setUint32(data) {
    view.setUint32(pos, data, true);
    pos += 4;
  }
}
*/
}
</script>
</body>
</html>
